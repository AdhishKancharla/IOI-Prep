1) Segment trees. just find functions which can be merged. 
2) convert mergesort tree type structures to pers if possible
3) knapsack with duplicates is solvable by breaking k = 1+2+4+8+...
4) Try applying different types of sqrt decomp. By nodes, or by queries. 
5) What we can do is perform some queries, and then revert them, and see what changes we incurred.This could be optimal in several cases. like dynamic MST. 
6) Apply exchange argument for greedy algorithms. Mainly, find the sorting parameter. what can help is checking only with N= 2 to find a sort parameter.
7) try to apply binsrch to determine the answer wherever possible. 
8) if its a tree problem, think about centroid decomp first. If during that decomp, you need to access information abt paths that go into the domain of a parallel centroid, then it means ur basically moving up in the centroid tree. Then ofcourse think in relation with a centroid tree. 
9) think about LCA based merging. also used s2L while merging always when possible. 
10) Try to convert DP problems into DAG problems.
11) treaps can be helpful sometimes. 
12) think about euler tours of a tree, including path euler tour. We can skip subtrees in the path version by marking first entry using + values and second using - ( or wtvr the inverse is, if present). That way, if entire subtree is skipped, stuff cancels out.
13) treedp can be sometimes simplified using HLD. 
14) try using Mo's, either the normal variant or the euler tour variant. 
 